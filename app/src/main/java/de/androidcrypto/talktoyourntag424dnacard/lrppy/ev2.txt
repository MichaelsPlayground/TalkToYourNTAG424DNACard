"""
This code was implemented based on AN12196.
"""

import io
import os
import struct
from enum import Enum
from typing import Tuple

from Crypto.Cipher import AES
from Crypto.Hash import CMAC
from Crypto.Util.strxor import strxor
from Crypto.Util.Padding import unpad

class CryptoComm:
    """
    This class represents an authenticated session after AuthentivateEV2 command.
    It offers the ability to prepare APDUs for CommMode.MAC or CommMode.FULL and validate R-APDUs in these modes.
    """

    def __init__(self, k_ses_auth_mac: bytes,
                 k_ses_auth_enc: bytes = None,
                 *,
                 ti: bytes = None,
                 cmd_counter: int = 0,
                 pdcap2: bytes = None,
                 pcdcap2: bytes = None):
        self.k_ses_auth_mac = k_ses_auth_mac
        self.k_ses_auth_enc = k_ses_auth_enc
        self.ti = ti
        self.cmd_counter = cmd_counter
        self.pdcap2 = pdcap2
        self.pcdcap2 = pcdcap2

    def encrypt_apdu(self, apdu, data_offset):
        """
        Convert CommMode.PLAIN APDU into CommMode.FULL
        :param apdu: Plain APDU
        :param data_offset: length of the command header (how many data bytes should get through unencrypted)
        :return: Encrypted APDU
        """
        require("APDU CLS=0x90", apdu[0] == 0x90)
        require("APDU P1=0x00", apdu[2] == 0x00)
        require("APDU P2=0x00", apdu[3] == 0x00)
        require("APDU Lc valid", apdu[4] == len(apdu) - 6)
        require("APDU Le=0x00", apdu[-1] == 0x00)

        header = apdu[5:5 + data_offset]

        iv_b = b"\xA5\x5A" + self.ti + struct.pack("<H", self.cmd_counter) + 8 * b"\x00"
        cipher = AES.new(self.k_ses_auth_enc, AES.MODE_ECB)
        iv = cipher.encrypt(iv_b)

        plainstream = io.BytesIO()
        plainstream.write(apdu[5+data_offset:-1])

        # don't encrypt if the command doesn't contain any data
        if len(apdu[5+data_offset:-1]) == 0:
            return self.sign_apdu(apdu)

        # byte \x80 has to be always appended by convention, even if
        # the block is already divisible by AES.block_size
        plainstream.write(b"\x80")

        # zero-pad until block is full
        while plainstream.getbuffer().nbytes % AES.block_size != 0:
            plainstream.write(b"\x00")

        cipher = AES.new(self.k_ses_auth_enc, AES.MODE_CBC, IV=iv)
        enc = cipher.encrypt(plainstream.getvalue())
        new_len = bytes([len(header) + len(enc)])
        require("APDU Data shorter than 256 bytes", len(new_len) == 1)

        return self.sign_apdu(b"\x90" + apdu[1:2] + b"\x00\x00" + new_len + header + enc + b"\x00")

    def parse_response(self, res: bytes) -> Tuple[bytes, bytes]:
        """
        Parse and check signature for R-APDU
        :param res: R-APDU
        :return: tuple(status code, response data)
        """
        require("Response code 91xx", res[-2] == 0x91)
        status = res[-2:]
        mact = res[-10:-2]
        data = res[:-10]

        our_mact = self.calc_raw_data(status[1:2] + struct.pack("<H", self.cmd_counter) + self.ti + data)

        require("Received MAC == calculated MAC", mact == our_mact)
        return status, data

    def decrypt_response(self, data: bytes) -> bytes:
        """
        Decrypt CommMode.FULL response data
        :param data: encrypted response data returned from validate_response()
        :return: decrypted data without padding
        """
        if not len(data):
            return b""

        iv_b = b"\x5A\xA5" + self.ti + struct.pack("<H", self.cmd_counter) + 8 * b"\x00"
        cipher = AES.new(self.k_ses_auth_enc, AES.MODE_ECB)
        iv = cipher.encrypt(iv_b)

        cipher = AES.new(self.k_ses_auth_enc, AES.MODE_CBC, IV=iv)
        return unpad(cipher.decrypt(data), AES.block_size, "iso7816")

    def unwrap_res(self, res: bytes, mode: CommMode) -> Tuple[bytes, bytes]:
        """
        Process response in any communication mode
        :param res: R-APDU (bytes)
        :param mode: CommMode
        :return: tuple(status, response data)
        """
        if mode == CommMode.PLAIN:
            require("Response code 91xx", res[-2] == 0x91)
            status_code = res[-2:]
            data = res[:-2]
            return status_code, data
        elif mode == CommMode.MAC:
            status_code, data = self.parse_response(res)
            return status_code, data
        elif mode == CommMode.FULL:
            status_code, enc_data = self.parse_response(res)
            return status_code, self.decrypt_response(enc_data)
